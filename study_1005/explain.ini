- 버블 정렬(Bubble Sort) : 이웃한 두 요소를 비교하여 큰 값(작은 값)을 뒤로 거품처럼 떠오르게 하는 방식

1. 리스트의 처음부터 시작해서 이웃한 두 요소를 비교한다.
2. 만약 첫 번째 요소가 두 번째 요소보다 크다면 두 요소의 위치를 바꾼다.
3. 위 과정을 리스트의 마지막까지 반복한다. (가장 큰 값이 리스트의 마지막 위치로 이동)
4. 위 과정을 전체 리스트에 대해 반복하여 전체 리스트를 정렬한다.

[29, 10, 14, 37, 13]
[10, 29, 14, 37, 13]
[10, 14, 29, 37, 13]
[10, 14, 29, 13, 37]
[10, 14, 13, 29, 37]
[10, 13, 14, 29, 37]
[10, 13, 14, 29, 37]

시간복잡도 : O(n^2)

-> example 예제 참고

- 병합 정렬(Merge Sort) : 분할 정복(Divide and Conquer) 방식을 사용하는 알고리즘
    리스트를 계속 반으로 나누어 각 부분을 개별적으로 정렬한 뒤 합치면서 리스트를 정렬하는 방식

1. 주어진 리스트를 절반으로 나눈다. 각 부분의 리스트의 크기가 1이 될 때까지 반복한다.
2. 각 부분을 병합하면서 정렬한다. 두 부분의 첫 번째 요소부터 비교하여 결과 리스트에 추가한다.
3. 한 부분의 리스트의 모든 요소가 결과에 추가되면 남은 요소를 전부 추가한다.
4. 위 과정을 전체 부분에 대해 반복하여 리스트를 정렬한다.

[29, 10, 14, 37, 13]
[29, 10, 14], [37, 13]
[29, 10], [14], [37], [13]
[29], [10], [14], [37], [13]
[10, 29], [14], [37], [13]
[10, 14, 29], [13, 37]
[10, 13, 14, 29, 37]

시간복잡도 : O(n log n)

- 퀵 정렬(Quick Sort) : 분할 정복(Divide and Conquer) 방식을 사용하는 알고리즘
퀵 정렬은 리스트를 임의의 피벗값으로 분할하고, 피벗보다 작은 값은 왼쪽 큰 값은 오른쪽으로 이동시킨다

1. 리스트의 하나의 요소를 선택한다. 이를 피벗이라고 부른다.
2. 피벗을 기준으로 리스트를 두 부분으로 분할한다. (피벗보다 작은 부분과 피벗보다 큰 부분)
3. 각 부분 리스트의 위 과정을 재귀적으로 반복해서 리스트를 정렬한다.

[29, 10, 14, 37, 13]
[10, 13], 14, [29, 37]
[10, 13, 14, 29, 37]

평균 시간 복잡도 : O(n log n)
최악의 경우 : O(n^2)

실제 서비스에서 일반적으로 좋은 성능을 보여주며, 인-플레이스 알고리즘으로
추가 메모리를 거의 사용하지 않아 많이 사용된다.

- 탐욕(Greedy) 알고리즘 : 문제를 해결하는 과정에서 그 순간순간 최적이라고 생각되는 결정을 하는 방식
지역적으로 최선의 선택을 하여 전체적으로 최적의 결과를 도출하겠다.

탐욕적 선택 속성 : 현재의 선택이 그 이후의 선택에 영향을 주지 않는다.
최적 부분 구조 : 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 해결방법으로 큰 문제를 해결할 수 있다.